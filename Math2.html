<html>
  <head>
    <style type="text/css">
      .selected {
        border-bottom: 1px solid red;
        border-right: 1px solid red;
      }
      .pass { color: green; display: none; }
      .fail { color: red; }
      .mathdiv {
        padding: 5px;
      }
      .empty {
        border: 1px solid gray;
        min-width: 1em;
        min-height: 1em;
      }
      .lhs { color: green; }
      .rhs { color: blue; }
      .equality { color: orange; }
      #output {
        border-top: 1px solid gray;
        padding: 0px;
        margin: 0px;
        list-style: decimal inside;
      }
      #output li {
        min-height: 2em;
        border-bottom: 1px solid gray;
        border-left: 1px solid gray;
        padding: 0.25em 0px 0px 0.25em;
      }
      .button {
        float: right;
        padding-top: 0.4em;
        margin-top: -0.3em;
        text-align: center;
        height: 2em;
        width: 2em;
        border-left: 1px solid gray;
      }
      .button:hover {
        background-color: lightblue;
      }
    </style>
    <script type="text/javascript" src="tests.js"></script>
    <script type="text/javascript;version=1.8">
    /* TODO:
      plus-minus support
      clicking in element
      backspace problems
      text input
      save/restore
      plotting/graphing
      simplify "is this a function/var. get me the root elt of this one." calls
      allow text input
      allow moving equations around? - have to ensure they are evaluated in the right order
      solve equations?
      y = x^2 should convert to a function?
      a single line failing shouldn't keep other, unrelated lines from evaling
      matrix math - started, but we need a matrix class, matrix multiplications should convert to different js
                    method for resizing?
                    vector support
      complex number support?
    */
      function start() {
        Editor.init();
        //output = document.getElementById("output");
        runTests(document.getElementById("testResults"));
        setTimeout(function() {
          addEquation();
        }, 2000)
      }
      var invisibleTimes = String.fromCharCode(0x00B7);
      var emptyBox = String.fromCharCode(0x25A1);
      var MMLNS = "http://www.w3.org/1998/Math/MathML";
      var Operators = [43, // +
                       45, // -
                       42, // *
                       47, // /
                       61, // =
                       94, // ^
                       95];// _
      var Editor = {
        init: function() {
          document.addEventListener("mouseup", this, false);
          window.addEventListener("keypress", this, false);
        },
        mathMode: true,
        handleEvent: function(aEvent) {
          switch (aEvent.type) {
            case "keypress" :
              MathEditor.handleEvent(aEvent);
              break;
            case "mouseup" :
              var t = aEvent.target;
              while(t && t.namespaceURI != MMLNS) {
                t = t.parentNode;
              }
              if (t) {
                MathEditor.setCursor(t, 0);
                return;
              }
              /*
              var div = document.createElement("div");
              div.classList.add("mathdiv");
              div.style.position = "absolute";
              div.style.top = aEvent.clientY;
              div.style.left = aEvent.clientX;
              div.setAttribute("contentEditable", "true");
              document.body.appendChild(div);

              if (this.mathMode) {
                MathEditor.startEdit(div);
              }
              */
              break;
          }
        },
      }
      var MathEditor = {
        node: false,
        createNode: function(aName, aContent) {
          var tag = document.createElementNS(MMLNS, aName);
          if (aContent) tag.textContent = aContent;
          return tag;
        },
        getCurrent: function() {
          /*
          var selObj = window.getSelection();
          let node = selObj.anchorNode;
          if (node.nodeName == "#text")
            node = node.parentNode;
          return node;
          */
          return this.selectedNode;
        },
        startEdit: function(aRoot) {
          var math = this.createNode("math");
          aRoot.appendChild(math);

          var row = this.createNode("mrow");
          row.classList.add("lhs");
          math.appendChild(row);
          this.setCursor(row, 0);
        },
        selectedNode: null,
        setCursor: function(aNode, aOffset) {
          if (aNode.nodeName == "math")
            return;
          /*
          var selObj = window.getSelection();
          var range = selObj.getRangeAt(0);
          range.setStart(aNode, aOffset);
          range.collapse(true);
          */

          if (this.selectedNode && this.selectedNode.classList)
            this.selectedNode.classList.remove("selected");
          this.selectedNode = aNode;
          this.selectedNode.classList.add("selected");
        },
        handleEvent: function(aEvent) {
          aEvent.preventDefault();
          var node = this.getCurrent();
          var char = String.fromCharCode(aEvent.charCode);
          var newNode;
          var mathElt = this.getMathElt(this.getCurrent());
          var eq = this.getEquality(mathElt);
          var isFunction = this.looksLikeFunction(node);
          var isVar = this.looksLikeVar(node);

          if (/[a-zA-Z]/.test(char)) {
            newNode = this.addChar(char, node);
          } else if (/[0-9\.]/.test(char)) {
            newNode = this.addNumber(char, node);
          } else if (char == "+" || char == "-" || char == "(" || char == ")" || char == ",") {
            newNode = this.appendNewNode("mo", char, node);
          } else if (char == "*") {
            newNode = this.appendNewNode("mo", invisibleTimes, node);
          } else if (char == "/") {
            var mfrac = this.createNode("mfrac");
            var mrow = this.createNode("mrow");
            node.parentNode.insertBefore(mfrac, node);
            mfrac.appendChild(node);
            mfrac.appendChild(mrow);
            this.setCursor(mrow);
            newNode = mrow;
          } else if (char == "^") {
            var mfrac = this.createNode("msup");
            var mrow = this.createNode("mrow");
            node.parentNode.insertBefore(mfrac, node);
            mfrac.appendChild(node);
            mfrac.appendChild(mrow);
            this.setCursor(mrow);
            newNode = mrow;
          } else if (char == "_") {
            var mfrac = this.createNode("msub");
            var mrow = this.createNode("mrow");
            node.parentNode.insertBefore(mfrac, node);
            mfrac.appendChild(node);
            mfrac.appendChild(mrow);
            this.setCursor(mrow);
            newNode = mrow;
          } else if (char == "=") {
            if (!eq) {
              eq = this.appendNewNode("mo", char, mathElt);
              eq.classList.add("equality");
              if (isFunction || isVar) {
                var row = this.appendNewNode("mrow", "", eq);
                row.classList.add("rhs");
              }
            }
            newNode = node;
          } else if (char == "\\") {
            var msqrt = this.createNode("msqrt");
            console.log(node.getAttribute("class"));
            if (node.getAttribute("class") == ("lhs selected")) {
              console.log("Add node");
              node = this.appendNewNode("mi", emptyBox, node);
            }
            node.parentNode.insertBefore(msqrt, node);
            msqrt.appendChild(node);
            this.setCursor(node);
            newNode = node;
          } else if (char == " ") {
            this.setCursor(node.parentNode, 0);
            return;
          } else if (char == "[") {
            var row = this.appendNewNode("mrow", "", node);
            var mo  = this.appendNewNode("mo", char, row);
            var mtable = this.appendNewNode("mtable", "", row);
            for(var i = 0; i < 2; i++) {
              var mtr = this.appendNewNode("mtr", "", mtable);
              for (var j = 0; j < 2; j++) {
                var mtd = this.appendNewNode("mtd", "", mtr);
                var mi = this.appendNewNode("mi", emptyBox, mtd);
                if (j == 0 && i == 0)
                  newNode = mi;
              }
            }
            mo = this.appendNewNode("mo", "]", row);
            this.setCursor(newNode);
          } else if (aEvent.keyCode == 8) { // backspace/delete on my mac?
            if (this.textNodeTypes.indexOf(node.nodeName) > -1) {
              if (!this.isEmpty(node)) {
                node.textContent = node.textContent.slice(0, node.textContent.length-1);
                return;
              }
            }
            console.log("not a text node");
            this.selectPrev(node);
            node.parentNode.removeChild(node);
            return;
          } else if (aEvent.keyCode == 37 || aEvent.keyCode == 38) { // left, up
            this.selectPrev(node);
            return;
          } else if (aEvent.keyCode == 39 || aEvent.keyCode == 40) { // right, down
            this.selectNext(node);
            return;
          } else if (aEvent.keyCode == 13) { // enter
            addEquation();
            return;
          } else {
            console.log("Unknown: " + aEvent.charCode + ", " + aEvent.keyCode);
          }

          if (eq && !isFunction && !isVar) {
            while (eq.nextSibling) {
              eq.parentNode.removeChild(eq.nextSibling);
            }
            var txt = this.evalCurrent();
            var row = this.appendNewNode("mrow", "", eq);
            row.classList.add("rhs");
            row.classList.add("generated");
            this.appendNewNode("mn", txt, row);
            if (newNode) this.setCursor(newNode);
          }
        },
        selectPrev: function(node) {
          if (node.nodeName == "math" || /lhs/.test(node.className))
            return;
          if (node.previousSibling) {
            console.log("select previous <" + node.previousSibling.nodeName + ">" + node.previousSibling.textContent);
            this.setCursor(node.previousSibling);
          } else if (node.parentNode.firstChild == node) {
            console.log("prev use parent <" + node.parentNode.nodeName + ">" + node.parentNode.textContent)
            this.selectPrev(node.parentNode);
          } else {
            console.log("prev select parent <" + node.parentNode.nodeName + ">" + node.parentNode.textContent)
            this.setCursor(node.parentNode);
          }
        },
        selectNext: function(node) {
          if (node.childNodes.length > 0 && node.firstChild.nodeName != "#text") {
            console.log("set to child");
            this.setCursor(node.firstChild);
          } else if (node.nextSibling) {
            console.log("set to next sibling");
            this.setCursor(node.nextSibling);
          } else if (node.parentNode.lastChild == node) {
            console.log("select next parent");
            if (node.parentNode.nextSibling)
              this.selectNext(node.parentNode.nextSibling);
            else
              this.selectNext(node.parentNode);
          }
        },
        looksLikeFunction: function(aNode) {
          var root = this.getMathElt(aNode);
          var lhs = root.querySelector(".lhs");
          var string = this.getJSFor(lhs);
          return /^[a-zA-Z]\([a-zA-Z,]*\)$/.test(string);
        },
        looksLikeVar: function(aNode) {
          var root = this.getMathElt(aNode);
          var lhs = root.querySelector(".lhs");
          var string = this.getJSFor(lhs);
          return /^[a-zA-Z]*$/.test(string);
        },
        getEquality: function(aRoot) {
          if (!aRoot) return null;
          return aRoot.querySelector("mo.equality");
        },
        evalCurrent: function() {
          var output = document.getElementById("output");
          var mathElt = this.getMathElt(this.getCurrent());
          var js = "";
          for (var i = 0; i < output.childNodes.length; i++) {
            var rowMathElt = output.childNodes[i].querySelector("math");

            js += this.getJSFor(rowMathElt);
            js += ";"

            if (rowMathElt == mathElt) break;
          }
          var res = "";
          try { res = eval(js);
          } catch(ex) { res = ex; }
          return res;
        },
        isEmpty: function(aNode) {
          return !aNode.textContent || aNode.textContent == emptyBox;
        },
        addNumber: function(aChar, aNode) { return this.updateNode("mn", aChar, aNode); },
        addChar: function(aChar, aNode) { return this.updateNode("mi", aChar, aNode); },
        textNodeTypes: ["mi", "mn"],
        updateNode: function(aName, aChar, aNode) {
          if (aNode.nodeName == aName)
            return this.appendToNode(aChar, aNode)
          else if (this.textNodeTypes.indexOf(aNode.nodeName) > -1) {
            if (this.isEmpty(aNode))
              return this.replaceNode(aName, aChar, aNode);
            else
              return this.multiplyCurrent(aChar, aNode, aName);
          } else {
            return this.appendNewNode(aName, aChar, aNode);
          }
        },
        replaceNode: function(aName, aChar, aNode) {
          this.appendNewNode(aName, aChar, aNode);
          aNode.parentNode.removeChild(aNode);
        },
        appendNewNode: function(aName, aChar, aNode) {
          var newNode = this.createNode(aName);
          newNode.textContent = aChar;
          if (aNode.nodeName == "mrow" || aNode.nodeName == "math" || aNode.nodeName == "mtable" || aNode.nodeName == "mtr" || aNode.nodeName == "mtd") {
            aNode.appendChild(newNode);
          } else if (aNode.parentNode) {
            if (aNode.nextSibling) aNode.parentNode.insertBefore(newNode, aNode.nextSibling);
            else aNode.parentNode.appendChild(newNode);
          } else {
            aNode.appendChild(newNode);
          }
          this.setCursor(newNode, 0);
          return newNode;
        },
        appendToNode: function(aChar, aNode) {
          if (aNode.textContent == emptyBox)
            aNode.textContent = aChar;
          else
            aNode.textContent += aChar;
          return aNode;
        },
        multiplyCurrent: function(aChar, aNode, aNewNodeName) {
          let newNode = this.appendNewNode("mo", invisibleTimes, aNode);
          return this.appendNewNode(aNewNodeName, aChar, newNode);
        },
        getMathElt: function(aNode) {
          if (!aNode) aNode = this.getCurrent();
          var root = aNode;
          while(root && root.nodeName != "math") {
            root = root.parentNode;
          }
          if (!root)
            root =this.startEdit(aNode);
          return root;
        },
        toJSString: function() {
          var output = document.getElementById("output");
          var txt = "";
          for (var i = 0; i < output.childNodes.length; i++) {
            var mathElt = output.childNodes[i].querySelector("math");
            txt += this.getJSFor(mathElt);
            txt += ";"

          }
          return txt;
        },
        getJSFor: function(aNode) {
          var txt = "";
          if (!aNode) return txt;
          if (aNode.nodeName == "math") {
            // we only do this check if we're looking at a root node (otherwise we'll hit an infinite loop)
            var isFun = this.looksLikeFunction(aNode);
            if (isFun) txt += "function ";
            var isVar = this.looksLikeVar(aNode);
            if (isVar) txt += "var ";

            for (var i = 0; i < aNode.childNodes.length; i++) {
              var node = aNode.childNodes[i];
              if (node.nodeName == "mo" && node.textContent == "=") {
                if (!isFun && !isVar)
                  break;
                else if (isFun)
                  txt += "{return ";
                else
                  txt += "=";
              } else {
                txt += this.getJSFor(node);
              }
            }
            if (isFun) txt += "}";
          } else if ( (aNode.nodeName == "mrow") && aNode.childNodes.length > 0) {
            var className = aNode.getAttribute("class");
            var isSide = /[lhs|rhs]/.test(className);
            if (!isSide) txt += "(";
            for (var i = 0; i < aNode.childNodes.length; i++) {
              var node = aNode.childNodes[i];
              txt += this.getJSFor(node);
            }
            if (!isSide) txt += ")";
          } else  if (aNode.nodeName == "mfrac") {
            txt += this.getJSFor(aNode.childNodes[0]);
            txt += "/";
            txt += this.getJSFor(aNode.childNodes[1]);
          } else  if (aNode.nodeName == "msup") {
            txt += "Math.pow(";
            txt += this.getJSFor(aNode.childNodes[0]);
            txt += ",";
            txt += this.getJSFor(aNode.childNodes[1]);
            txt += ")";
          } else if (aNode.nodeName == "msub") {
            txt += this.getJSFor(aNode.childNodes[0]);
          } else if (aNode.nodeName == "msqrt") {
            txt += "Math.sqrt(";
            for (var i = 0; i < aNode.childNodes.length; i++) {
              var node = aNode.childNodes[i];
              txt += this.getJSFor(node);
            }
            txt += ")";
          } else if (aNode.nodeName == "mi" || aNode.nodeName == "mn") {
            if (aNode.nodeName == "mi" && aNode.textContent == "sin") {
              txt += "Math.sin";
            } else if (aNode.nodeName == "mi" && aNode.textContent == "cos") {
              txt += "Math.cos";
            } else {
              txt = aNode.textContent;
            }
          } else if (aNode.nodeName == "mo") {
            if (aNode.textContent == invisibleTimes)
              txt += "*";
            else if (aNode.textContent == "[")
              txt += "Matrix("
            else if (aNode.textContent == "]")
              txt += ")"
            else
              txt = aNode.textContent;
          } else if (aNode.nodeName == "mtable") {
            txt += this.addChildrenWithSep(aNode, ",");
          } else if (aNode.nodeName == "mtr") {
            txt += "[";
            txt += this.addChildrenWithSep(aNode, ",");
            txt += "]";
          } else if (aNode.nodeName == "mtd") {
            txt += this.addChildrenWithSep(aNode, ",");
          }
          return txt;
        },
        addChildrenWithSep: function(aNode, aSep) {
          var txt = "";
          for (var i = 0; i < aNode.childNodes.length; i++) {
            txt += this.getJSFor(aNode.childNodes[i]);
            if (i < aNode.childNodes.length-1)
              txt += aSep;
          }
          return txt;
        }
      }

      var SVGNS = "http://www.w3.org/2000/svg";
      function Plot(aFunction, aNode) {
        this.width = 200;
        this.height = 200;
        this.svg = document.createElementNS(SVGNS, "svg");
        aNode.appendChild(this.svg);
        this.fun = aFunction;// + "f(x)";
        this.svg.setAttribute("width", this.width);
        this.svg.setAttribute("height", this.height);

        this.box = this.createElt("box", {
          fill: "none",
          stroke: "black",
          x: 1,
          y: 1,
          width: this.width-2,
          height: this.height-2
        })
        this.svg.appendChild(this.box);

        this.g = this.createElt("g", {
          transform: "scale(" + (this.height/10) + ")translate(" + 5 + "," + 5 + ")scale(1,-1)"
        });
        this.path = this.createElt("path", {
          fill: "none",
          stroke: "black",
          "stroke-width": 0.1
        });
        this.xaxis = this.createElt("line", {
          x1: -10, x2: 10,
          y1: 0,   y2:  0,
          stroke: "gray",
          "stroke-width": 0.01
        });
        this.g.appendChild(this.xaxis);
        this.yaxis = this.createElt("line", {
          x1: 0,   x2:  0,
          y1: -10, y2: 10,
          stroke: "gray",
          "stroke-width": 0.01
        });
        this.g.appendChild(this.yaxis);
        var d = "M ";
        for (var x = -10; x <= 10; x += 0.1) {
          try {
            // TODO - add an isFirst variable to determine which letter to write before the numbers
            x = Math.round(x*10)/10;
            res = eval(this.fun);
            if (res) {
              d += x + " " + res;
              if ( x != 10 ) d += " L ";
            }
          } catch(ex) { console.log(ex); }
        }
        this.path.setAttribute("d", d);
        this.g.appendChild(this.path);
        this.svg.appendChild(this.g);
      }
      Plot.prototype = {
        createElt: function(aName, aProps) {
          var elt = document.createElementNS(SVGNS, aName);
          for (var prop in aProps) {
            elt.setAttribute(prop, aProps[prop]);
          }
          return elt;
        }
      }

      function addPlot(aPrevSibling) {
        var math = null;
        if (aPrevSibling) {
          math = aPrevSibling.querySelector("math");
        }
        if (!math) math = MathEditor.getMathElt();

        var lhs = math.querySelector(".lhs");
        console.log("LHS: " + MathEditor.getJSFor(lhs));
        var equation = MathEditor.toJSString() + MathEditor.getJSFor(lhs);

        var li = document.createElement("li");

        var button = document.createElement("div");
        button.textContent = "-";
        button.classList.add("button");
        button.addEventListener("click", function() {
          li.parentNode.removeChild(li)
        }, false);
        li.appendChild(button);

        if (aPrevSibling) {
          if (aPrevSibling.nextSibling) aPrevSibling.parentNode.insertBefore(li, aPrevSibling.nextSibling);
          else aPrevSibling.parentNode.appendChild(li);
        } else {
          document.getElementById("output").appendChild(li);
        }
        var p = new Plot(equation, li);
      }

      function addEquation(aPrevSibling) {
        var li = document.createElement("li");

        var button = document.createElement("div");
        button.textContent = "+";
        button.classList.add("button");
        button.addEventListener("click", function() {
          addEquation(li)
        }, false);
        li.appendChild(button);

        button = document.createElement("div");
        button.textContent = "-";
        button.classList.add("button");
        button.addEventListener("click", function() {
          li.parentNode.removeChild(li)
        }, false);
        li.appendChild(button);

        button = document.createElement("div");
        button.textContent = "Plot";
        button.classList.add("button");
        button.addEventListener("click", function() {
          addPlot(li)
        }, false);
        li.appendChild(button);

        if (aPrevSibling) {
          if (aPrevSibling.nextSibling) aPrevSibling.parentNode.insertBefore(li, aPrevSibling.nextSibling);
          else aPrevSibling.parentNode.appendChild(li);
        } else {
          document.getElementById("output").appendChild(li);
        }
        MathEditor.startEdit(li);
      }
    </script>
  </head>
  <body onload="start();" style="margin: 0px;">
    <div class="toolbar" style="height: 3em; width: 100%; border-bottom: 1px solid black; background-image: -moz-linear-gradient(gray, darkgray);">
      <span style="display: inline-block; width: 3em; height: 2em; border-right: 1px solid black; text-align: center; padding-top: 1em;" onclick="addEquation();">+</span>
      <span style="display: inline-block; width: 3em; height: 2em; border-right: 1px solid black; text-align: center; padding-top: 1em;" onclick="addPlot();">Plot</span>
    </div>
    <ol id="output"></ol>
    <ul id="testResults"></ul>
  </body>
</html>